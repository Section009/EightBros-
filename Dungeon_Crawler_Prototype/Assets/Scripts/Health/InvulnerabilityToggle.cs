using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Makes an actor temporarily immune by either:
///  - Disabling all colliders (default, safest), or
///  - Switching the whole hierarchy to a specific layer (requires weapon LayerMasks).
/// 
/// Call EnableInvulnerability() to enter, DisableInvulnerability() to exit.
/// Safe to call multiple times; nested enables are reference-counted.
/// </summary>
public class InvulnerabilityToggle : MonoBehaviour
{
    public enum Mode { DisableColliders, SwitchLayer }
    [Header("Mode")]
    public Mode mode = Mode.DisableColliders;

    [Header("SwitchLayer settings (used only if Mode=SwitchLayer)")]
    [Tooltip("Layer name to use while invulnerable (e.g., 'Invulnerable').")]
    public string invulnerableLayerName = "Invulnerable";

    // internal
    int _invulnLayer = -1;
    int _stackCount = 0;

    // for DisableColliders mode
    List<Collider> _colliders = new List<Collider>();
    List<bool> _prevEnabled = new List<bool>();

    // for SwitchLayer mode
    struct SavedLayer { public Transform t; public int layer; }
    List<SavedLayer> _savedLayers = new List<SavedLayer>();

    void Awake()
    {
        if (mode == Mode.DisableColliders)
        {
            GetComponentsInChildren(true, _colliders);
            _prevEnabled.Capacity = _colliders.Count;
        }
        else
        {
            _invulnLayer = LayerMask.NameToLayer(invulnerableLayerName);
            if (_invulnLayer < 0)
            {
                Debug.LogWarning($"[InvulnerabilityToggle] Layer '{invulnerableLayerName}' not found. " +
                                 $"Create it in Project Settings > Tags and Layers, or switch to DisableColliders mode.");
            }
        }
    }

    public void EnableInvulnerability()
    {
        _stackCount++;
        if (_stackCount > 1) return; // already enabled

        if (mode == Mode.DisableColliders)
        {
            _prevEnabled.Clear();
            for (int i = 0; i < _colliders.Count; i++)
            {
                var c = _colliders[i];
                if (!c) continue;
                _prevEnabled.Add(c.enabled);
                c.enabled = false;
            }
        }
        else
        {
            if (_invulnLayer < 0) return;
            _savedLayers.Clear();
            foreach (Transform t in GetComponentsInChildren<Transform>(true))
            {
                _savedLayers.Add(new SavedLayer { t = t, layer = t.gameObject.layer });
                t.gameObject.layer = _invulnLayer;
            }
        }
    }

    public void DisableInvulnerability()
    {
        if (_stackCount == 0) return;
        _stackCount--;
        if (_stackCount > 0) return; // still in nested invuln

        if (mode == Mode.DisableColliders)
        {
            // restore colliders (if list changed at runtime, best-effort)
            int savedCount = _prevEnabled.Count;
            for (int i = 0, j = 0; i < _colliders.Count && j < savedCount; i++, j++)
            {
                var c = _colliders[i];
                if (!c) continue;
                c.enabled = _prevEnabled[j];
            }
            _prevEnabled.Clear();
        }
        else
        {
            // restore layers
            for (int i = 0; i < _savedLayers.Count; i++)
            {
                var s = _savedLayers[i];
                if (s.t) s.t.gameObject.layer = s.layer;
            }
            _savedLayers.Clear();
        }
    }

    void OnDisable()  { ForceOff(); }
    void OnDestroy()  { ForceOff(); }

    void ForceOff()
    {
        // ensure clean state if object gets disabled/destroyed mid-invuln
        _stackCount = 1;
        DisableInvulnerability();
    }
}
